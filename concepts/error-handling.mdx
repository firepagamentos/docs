---
title: "Tratamento de Erros"
description: "Guia completo para identificar, tratar e recuperar-se de erros na API FireBanking"
---

## Vis√£o Geral

Uma implementa√ß√£o robusta da API FireBanking requer **tratamento adequado de erros** para garantir a melhor experi√™ncia do usu√°rio e a confiabilidade do sistema. Este guia cobre os diferentes tipos de erro e as estrat√©gias recomendadas para cada cen√°rio.

## C√≥digos de Status HTTP

### Respostas de Sucesso (2xx)

- `200 OK` - Requisi√ß√£o processada com sucesso
- `201 Created` - Recurso criado com sucesso
- `204 No Content` - Opera√ß√£o bem-sucedida sem conte√∫do de retorno

### Erros do Cliente (4xx)

- `400 Bad Request` - Dados inv√°lidos na requisi√ß√£o
- `401 Unauthorized` - Credenciais de autentica√ß√£o inv√°lidas
- `403 Forbidden` - Acesso negado aos recursos
- `404 Not Found` - Recurso n√£o encontrado
- `422 Unprocessable Entity` - Dados v√°lidos mas regra de neg√≥cio violada
- `429 Too Many Requests` - Rate limit excedido

### Erros do Servidor (5xx)

- `500 Internal Server Error` - Erro interno do servidor
- `502 Bad Gateway` - Erro de gateway
- `503 Service Unavailable` - Servi√ßo temporariamente indispon√≠vel
- `504 Gateway Timeout` - Timeout de gateway

## Estrutura Padr√£o de Erro

### Formato de Resposta

```json
{
  "error": {
    "code": "INVALID_CARD_NUMBER",
    "message": "O n√∫mero do cart√£o fornecido √© inv√°lido",
    "details": "O n√∫mero do cart√£o deve conter entre 13 e 19 d√≠gitos",
    "request_id": "req_123456789",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

### Campos Explicados

- `code`: C√≥digo √∫nico do erro para tratamento program√°tico
- `message`: Mensagem em portugu√™s para o usu√°rio final
- `details`: Informa√ß√µes adicionais sobre o erro (opcional)
- `request_id`: Identificador √∫nico da requisi√ß√£o para suporte
- `timestamp`: Momento em que o erro ocorreu

## Tipos de Erro Comuns

### Erros de Valida√ß√£o (400 Bad Request)

<AccordionGroup>
  <Accordion title="Dados Obrigat√≥rios Ausentes">
    ```json
    {
      "error": {
        "code": "MISSING_REQUIRED_FIELD",
        "message": "Campo obrigat√≥rio n√£o informado: buyer.email",
        "details": "O email do comprador √© obrigat√≥rio para processamento"
      }
    }
    ```
    
    **A√ß√£o**: Verifique se todos os campos obrigat√≥rios est√£o sendo enviados
  </Accordion>
  
  <Accordion title="Formato Inv√°lido">
    ```json
    {
      "error": {
        "code": "INVALID_FORMAT",
        "message": "Formato inv√°lido para o campo amount",
        "details": "O valor deve ser um n√∫mero inteiro em reais"
      }
    }
    ```
    
    **A√ß√£o**: Corrija o formato dos dados conforme a documenta√ß√£o
  </Accordion>
</AccordionGroup>

### Erros de Autentica√ß√£o (401/403)

<AccordionGroup>
  <Accordion title="API Key Inv√°lida">
    ```json
    {
      "error": {
        "code": "INVALID_API_KEY",
        "message": "Chave de API inv√°lida ou expirada",
        "details": "Verifique sua chave de API no Dashboard"
      }
    }
    ```
    
    **A√ß√£o**: Verifique se a chave est√° correta e ativa no Dashboard
  </Accordion>
  
  <Accordion title="IP N√£o Autorizado">
    ```json
    {
      "error": {
        "code": "IP_NOT_WHITELISTED",
        "message": "IP n√£o est√° na lista de IPs autorizados",
        "details": "Adicione este IP na configura√ß√£o de seguran√ßa"
      }
    }
    ```
    
    **A√ß√£o**: Configure o IP no whitelist atrav√©s do Dashboard
  </Accordion>
</AccordionGroup>

### Erros de Transa√ß√£o (422)

#### Erros de Cart√£o de Cr√©dito

<AccordionGroup>
  <Accordion title="Cart√£o Recusado">
    ```json
    {
      "error": {
        "code": "CARD_DECLINED",
        "message": "Cart√£o recusado pelo banco emissor",
        "details": "Entre em contato com o banco para mais informa√ß√µes"
      }
    }
    ```

    **A√ß√£o**: Solicite ao cliente que entre em contato com o banco

  </Accordion>

  <Accordion title="Limite Insuficiente">
    ```json
    {
      "error": {
        "code": "INSUFFICIENT_FUNDS",
        "message": "Limite insuficiente no cart√£o",
        "details": "O valor excede o limite dispon√≠vel"
      }
    }
    ```

    **A√ß√£o**: Sugerir valor menor ou outro meio de pagamento

  </Accordion>

  <Accordion title="Token Expirado">
    ```json
    {
      "error": {
        "code": "TOKEN_EXPIRED",
        "message": "Token do cart√£o expirado",
        "details": "Solicite uma nova tokeniza√ß√£o do cart√£o"
      }
    }
    ```

    **A√ß√£o**: Redirecione para nova captura de dados do cart√£o

  </Accordion>

  <Accordion title="CVV Obrigat√≥rio">
    ```json
    {
      "error": {
        "code": "CVV_REQUIRED",
        "message": "CVV √© obrigat√≥rio para pagamento com token",
        "details": "Informe o c√≥digo de seguran√ßa para continuar"
      }
    }
    ```

    **A√ß√£o**: Solicite o CVV ao cliente para finalizar a transa√ß√£o

  </Accordion>

  <Accordion title="Transa√ß√£o J√° Capturada">
    ```json
    {
      "error": {
        "code": "ALREADY_CAPTURED",
        "message": "Esta transa√ß√£o j√° foi capturada",
        "details": "N√£o √© poss√≠vel capturar novamente"
      }
    }
    ```

    **A√ß√£o**: Verifique o status atual da transa√ß√£o

  </Accordion>
</AccordionGroup>

#### Erros de PIX

<AccordionGroup>
  <Accordion title="Chave PIX Inv√°lida">
    ```json
    {
      "error": {
        "code": "PIX_KEY_INVALID",
        "message": "Chave PIX inv√°lida ou n√£o encontrada",
        "details": "Verifique se a chave PIX est√° correta"
      }
    }
    ```

    **A√ß√£o**: Valide a chave PIX e solicite corre√ß√£o ao cliente

  </Accordion>

  <Accordion title="QR Code Expirado">
    ```json
    {
      "error": {
        "code": "QR_CODE_EXPIRED",
        "message": "QR Code PIX expirado",
        "details": "Gere um novo QR Code para continuar"
      }
    }
    ```

    **A√ß√£o**: Gere uma nova cobran√ßa PIX

  </Accordion>

  <Accordion title="Valor Fora dos Limites PIX">
    ```json
    {
      "error": {
        "code": "PIX_LIMIT_EXCEEDED",
        "message": "Valor excede limite PIX permitido",
        "details": "Valor m√°ximo: R$ 20.000 para pessoa f√≠sica"
      }
    }
    ```

    **A√ß√£o**: Ajuste o valor ou divida em m√∫ltiplas transa√ß√µes

  </Accordion>

  <Accordion title="PIX Fora do Hor√°rio">
    ```json
    {
      "error": {
        "code": "PIX_OUTSIDE_HOURS",
        "message": "PIX temporariamente indispon√≠vel",
        "details": "Hor√°rio de manuten√ß√£o do sistema PIX"
      }
    }
    ```

    **A√ß√£o**: Tente novamente em alguns minutos

  </Accordion>
</AccordionGroup>

#### Erros de Boleto Banc√°rio

<AccordionGroup>
  <Accordion title="Data de Vencimento Inv√°lida">
    ```json
    {
      "error": {
        "code": "INVALID_DUE_DATE",
        "message": "Data de vencimento inv√°lida",
        "details": "A data deve ser futura e at√© 90 dias"
      }
    }
    ```

    **A√ß√£o**: Ajuste a data de vencimento conforme as regras

  </Accordion>

  <Accordion title="Dados do Pagador Incompletos">
    ```json
    {
      "error": {
        "code": "PAYER_DATA_INCOMPLETE",
        "message": "Dados do pagador incompletos",
        "details": "Nome, documento e endere√ßo s√£o obrigat√≥rios"
      }
    }
    ```

    **A√ß√£o**: Complete todos os dados obrigat√≥rios do pagador

  </Accordion>

  <Accordion title="Boleto J√° Pago">
    ```json
    {
      "error": {
        "code": "ALREADY_PAID",
        "message": "Boleto j√° foi pago",
        "details": "N√£o √© poss√≠vel cancelar boleto pago"
      }
    }
    ```

    **A√ß√£o**: Verifique o status atual do boleto

  </Accordion>

  <Accordion title="Valor Abaixo do M√≠nimo">
    ```json
    {
      "error": {
        "code": "AMOUNT_TOO_LOW",
        "message": "Valor abaixo do m√≠nimo para boleto",
        "details": "Valor m√≠nimo: R$ 2,50"
      }
    }
    ```

    **A√ß√£o**: Ajuste o valor ou use outro meio de pagamento

  </Accordion>
</AccordionGroup>

## Estrat√©gias de Tratamento

### 1. Retry com Backoff Exponencial

Para erros tempor√°rios (5xx, timeouts):

<CodeGroup>
```python Python
import time
import random

def api_call_with_retry(func, max_retries=3):
for attempt in range(max_retries):
try:
return func()
except TemporaryError as e:
if attempt == max_retries - 1:
raise e

            # Backoff exponencial com jitter
            delay = (2 ** attempt) + random.uniform(0, 1)
            time.sleep(delay)

    raise Exception("Max retries exceeded")

````

```javascript Node.js
async function apiCallWithRetry(apiCall, maxRetries = 3) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            return await apiCall();
        } catch (error) {
            if (error.status >= 500 && attempt < maxRetries - 1) {
                // Backoff exponencial com jitter
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            }
            throw error;
        }
    }
}
````

</CodeGroup>

### 2. Circuit Breaker

Proteja sua aplica√ß√£o de falhas consecutivas:

```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN

    def call(self, func):
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time > self.timeout:
                self.state = 'HALF_OPEN'
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func()
            self.reset()
            return result
        except Exception as e:
            self.record_failure()
            raise e

    def record_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            self.state = 'OPEN'

    def reset(self):
        self.failure_count = 0
        self.state = 'CLOSED'
```

### 3. Tratamento por Categoria de Erro

<CodeGroup>
```python Python
def handle_firebanking_error(response, payment_method="credit_card"):
    error_data = response.json().get('error', {})
    error_code = error_data.get('code')

    if response.status_code == 400:
        # Erro de valida√ß√£o - n√£o tentar novamente
        log_validation_error(error_data)
        raise ValidationError(error_data['message'])

    elif response.status_code == 401:
        # Erro de autentica√ß√£o - verificar configura√ß√£o
        refresh_api_key()
        raise AuthenticationError("API key inv√°lida")

    elif response.status_code == 422:
        # Erro de neg√≥cio - tratar por produto
        if payment_method == "pix":
            return handle_pix_business_error(error_code, error_data)
        elif payment_method == "bank_slip":
            return handle_boleto_business_error(error_code, error_data)
        else:
            return handle_card_business_error(error_code, error_data)

    elif response.status_code >= 500:
        # Erro do servidor - tentar novamente
        raise TemporaryError("Erro tempor√°rio do servidor")

def handle_pix_business_error(error_code, error_data):
if error_code == "PIX_KEY_INVALID": # Solicitar nova chave PIX
raise PixKeyError("Chave PIX inv√°lida", retry_action="request_new_key")
elif error_code == "QR_CODE_EXPIRED": # Gerar novo QR Code
raise PixQRExpiredError("QR Code expirado", retry_action="generate_new_qr")
elif error_code == "PIX_LIMIT_EXCEEDED": # Sugerir divis√£o da transa√ß√£o
raise PixLimitError("Limite PIX excedido", retry_action="split_transaction")
else:
raise BusinessError(error_data['message'])

def handle_boleto_business_error(error_code, error_data):
if error_code == "INVALID_DUE_DATE": # Ajustar data de vencimento
raise BoletoDateError("Data inv√°lida", retry_action="adjust_due_date")
elif error_code == "PAYER_DATA_INCOMPLETE": # Solicitar dados completos
raise BoletoDataError("Dados incompletos", retry_action="complete_payer_data")
elif error_code == "ALREADY_PAID": # Verificar status atual
raise BoletoStatusError("Boleto j√° pago", retry_action="check_current_status")
else:
raise BusinessError(error_data['message'])

def handle_card_business_error(error_code, error_data):
if error_code == "CARD_DECLINED": # Sem retry autom√°tico
raise CardDeclinedError("Cart√£o recusado", retry_action="none")
elif error_code == "TOKEN_EXPIRED": # Solicitar nova tokeniza√ß√£o
raise TokenExpiredError("Token expirado", retry_action="retokenize")
elif error_code == "CVV_REQUIRED": # Solicitar CVV
raise CVVRequiredError("CVV obrigat√≥rio", retry_action="request_cvv")
else:
raise BusinessError(error_data['message'])

````

```javascript Node.js
function handleFireBankingError(response, paymentMethod = 'credit_card') {
    const { status, data } = response;
    const error = data.error;
    const errorCode = error?.code;

    switch(status) {
        case 400:
            console.error('Validation error:', error.message);
            throw new ValidationError(error.message);

        case 401:
        case 403:
            console.error('Authentication error:', error.message);
            throw new AuthenticationError(error.message);

        case 422:
            // Tratamento espec√≠fico por produto
            if (paymentMethod === 'pix') {
                return handlePixBusinessError(errorCode, error);
            } else if (paymentMethod === 'bank_slip') {
                return handleBoletoBusinessError(errorCode, error);
            } else {
                return handleCardBusinessError(errorCode, error);
            }

        case 429:
            const retryAfter = response.headers['retry-after'] || 60;
            throw new RateLimitError(`Rate limit exceeded. Retry after ${retryAfter}s`);

        default:
            if (status >= 500) {
                throw new TemporaryError('Server error');
            }
            throw new UnknownError(error.message);
    }
}

function handlePixBusinessError(errorCode, error) {
    switch(errorCode) {
        case 'PIX_KEY_INVALID':
            throw new PixKeyError('Chave PIX inv√°lida', { retryAction: 'requestNewKey' });
        case 'QR_CODE_EXPIRED':
            throw new PixQRExpiredError('QR Code expirado', { retryAction: 'generateNewQR' });
        case 'PIX_LIMIT_EXCEEDED':
            throw new PixLimitError('Limite PIX excedido', { retryAction: 'splitTransaction' });
        case 'PIX_OUTSIDE_HOURS':
            throw new PixMaintenanceError('PIX em manuten√ß√£o', { retryAction: 'retryLater' });
        default:
            throw new BusinessError(error.message);
    }
}

function handleBoletoBusinessError(errorCode, error) {
    switch(errorCode) {
        case 'INVALID_DUE_DATE':
            throw new BoletoDateError('Data de vencimento inv√°lida', { retryAction: 'adjustDueDate' });
        case 'PAYER_DATA_INCOMPLETE':
            throw new BoletoDataError('Dados do pagador incompletos', { retryAction: 'completePayerData' });
        case 'ALREADY_PAID':
            throw new BoletoStatusError('Boleto j√° pago', { retryAction: 'checkCurrentStatus' });
        case 'AMOUNT_TOO_LOW':
            throw new BoletoAmountError('Valor muito baixo', { retryAction: 'adjustAmount' });
        default:
            throw new BusinessError(error.message);
    }
}

function handleCardBusinessError(errorCode, error) {
    switch(errorCode) {
        case 'CARD_DECLINED':
            throw new CardDeclinedError('Cart√£o recusado', { retryAction: 'none' });
        case 'TOKEN_EXPIRED':
            throw new TokenExpiredError('Token expirado', { retryAction: 'retokenize' });
        case 'CVV_REQUIRED':
            throw new CVVRequiredError('CVV obrigat√≥rio', { retryAction: 'requestCVV' });
        case 'INSUFFICIENT_FUNDS':
            throw new InsufficientFundsError('Limite insuficiente', { retryAction: 'lowerAmount' });
        default:
            throw new BusinessError(error.message);
    }
}

// Exemplo de uso com retry inteligente
async function processPaymentWithSmartRetry(paymentData, paymentMethod) {
    try {
        return await firebanking.createPayment(paymentData);
    } catch (error) {
        const handledError = handleFireBankingError(error.response, paymentMethod);

        // Retry autom√°tico baseado no tipo de erro
        if (handledError.retryAction === 'generateNewQR') {
            // Gerar novo QR Code automaticamente
            return await generateNewQRCode(paymentData);
        } else if (handledError.retryAction === 'retryLater') {
            // Retry ap√≥s delay para manuten√ß√£o PIX
            await delay(300000); // 5 minutos
            return await processPaymentWithSmartRetry(paymentData, paymentMethod);
        }

        throw handledError;
    }
}
````

</CodeGroup>

## Tratamento de Webhooks com Falha

### Retry Autom√°tico de Webhooks

A FireBanking implementa retry autom√°tico para webhooks falhados com backoff exponencial:

- **1¬™ tentativa**: Imediata
- **2¬™ tentativa**: Ap√≥s 30 segundos
- **3¬™ tentativa**: Ap√≥s 5 minutos
- **4¬™ tentativa**: Ap√≥s 30 minutos
- **5¬™ tentativa**: Ap√≥s 2 horas

### Webhook de Falha Final

Quando todas as tentativas falharem, voc√™ receber√° um webhook especial:

```json
{
  "event": "webhook.failed",
  "data": {
    "original_event": "payment.completed",
    "transaction_id": "fb_trans_123456789",
    "failed_attempts": 5,
    "last_error": "Connection timeout",
    "last_attempt": "2024-01-15T12:30:00Z",
    "webhook_url": "https://meusite.com/webhook/failed"
  }
}
```

### Estrat√©gias de Recupera√ß√£o por Produto

#### PIX - Consulta de Status

```python
def recover_pix_transaction(transaction_id):
    try:
        # Consulta diretamente a transa√ß√£o PIX
        status = firebanking_client.get_pix_transaction(transaction_id)

        if status.status == 'PAID':
            # Processa pagamento que n√£o foi notificado
            process_pix_payment_confirmation(status)
        elif status.status == 'EXPIRED':
            # Notifica expira√ß√£o para o usu√°rio
            notify_pix_expiration(status)

    except Exception as e:
        log_error(f"Failed to recover PIX transaction {transaction_id}: {e}")

# Consulta peri√≥dica para PIX pendentes
def check_pending_pix_transactions():
    pending_pix = get_pending_pix_transactions()

    for pix in pending_pix:
        if datetime.now() - pix.created_at > timedelta(hours=1):
            recover_pix_transaction(pix.transaction_id)
```

#### Boleto - Verifica√ß√£o de Status

```python
def recover_boleto_transaction(boleto_id):
    try:
        # Consulta status atual do boleto
        boleto = firebanking_client.get_boleto(boleto_id)

        if boleto.status == 'PAID':
            # Processa pagamento confirmado
            process_boleto_payment(boleto)
        elif boleto.status == 'CANCELLED':
            # Notifica cancelamento
            notify_boleto_cancellation(boleto)
        elif boleto.status == 'OVERDUE':
            # Notifica vencimento
            notify_boleto_overdue(boleto)

    except Exception as e:
        log_error(f"Failed to recover boleto {boleto_id}: {e}")

# Verifica√ß√£o di√°ria de boletos
def daily_boleto_check():
    active_boletos = get_active_boletos()

    for boleto in active_boletos:
        if datetime.now().date() > boleto.due_date:
            recover_boleto_transaction(boleto.boleto_id)
```

#### Cart√£o - Verifica√ß√£o de Autoriza√ß√µes

```python
def recover_card_transaction(transaction_id):
    try:
        # Consulta status da transa√ß√£o de cart√£o
        transaction = firebanking_client.get_card_transaction(transaction_id)

        if transaction.status == 'AUTHORIZED':
            # Captura se necess√°rio
            if transaction.auto_capture:
                capture_card_payment(transaction_id)
        elif transaction.status == 'CAPTURED':
            # Confirma captura
            confirm_card_payment(transaction)
        elif transaction.status == 'DECLINED':
            # Notifica recusa
            notify_card_declined(transaction)

    except Exception as e:
        log_error(f"Failed to recover card transaction {transaction_id}: {e}")
```

### Implementa√ß√£o de Fallback

```python
@app.route('/webhook/fallback', methods=['POST'])
def webhook_fallback():
    """
    Endpoint alternativo para webhooks cr√≠ticos
    """
    data = request.get_json()

    try:
        # Log entrada do fallback
        log_webhook_fallback(data)

        # Processa baseado no tipo
        event_type = data.get('event')
        payment_method = data.get('payment_method')

        if payment_method == 'pix':
            handle_pix_fallback(data)
        elif payment_method == 'bank_slip':
            handle_boleto_fallback(data)
        elif payment_method == 'credit_card':
            handle_card_fallback(data)

        return '', 200

    except Exception as e:
        log_error(f"Webhook fallback failed: {e}")
        return '', 500

def handle_pix_fallback(data):
    """Recupera√ß√£o espec√≠fica para PIX"""
    transaction_id = data['data']['transaction_id']

    # For√ßa consulta de status
    recover_pix_transaction(transaction_id)

    # Notifica sistemas internos
    notify_internal_systems('pix_recovered', data)

def handle_boleto_fallback(data):
    """Recupera√ß√£o espec√≠fica para Boleto"""
    boleto_id = data['data']['boleto_id']

    # For√ßa consulta de status
    recover_boleto_transaction(boleto_id)

    # Atualiza cache local
    invalidate_boleto_cache(boleto_id)

def handle_card_fallback(data):
    """Recupera√ß√£o espec√≠fica para Cart√£o"""
    transaction_id = data['data']['transaction_id']

    # For√ßa consulta de status
    recover_card_transaction(transaction_id)

    # Verifica necessidade de captura
    check_pending_captures()
```

### Monitoramento de Webhooks

#### Dashboard de Webhooks

- **Taxa de entrega** por produto
- **Tempo m√©dio de entrega**
- **Webhooks falhados** por per√≠odo
- **URLs com maior taxa de falha**

#### Alertas Autom√°ticos

```python
def setup_webhook_alerts():
    # Alerta se taxa de falha > 5%
    if get_webhook_failure_rate() > 0.05:
        alert_webhook_high_failure()

    # Alerta se n√£o recebeu webhook em 1 hora
    if get_last_webhook_time() > timedelta(hours=1):
        alert_webhook_silence()

    # Alerta para URLs espec√≠ficas com falha
    failed_urls = get_failed_webhook_urls()
    if failed_urls:
        alert_specific_webhook_failures(failed_urls)
```

## Logging e Monitoramento

### Estrutura de Log Recomendada

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "level": "ERROR",
  "service": "firebanking-integration",
  "transaction_id": "fb_trans_123456789",
  "external_id": "pedido-001",
  "error_code": "CARD_DECLINED",
  "error_message": "Cart√£o recusado pelo banco emissor",
  "request_id": "req_123456789",
  "user_id": "user_789",
  "additional_context": {
    "amount": 100,
    "payment_method": "credit_card",
    "attempt_count": 1
  }
}
```

### M√©tricas de Monitoramento

#### M√©tricas Gerais

- **Taxa de erro por tipo** (4xx vs 5xx)
- **Tempo de resposta** por endpoint
- **Rate limit** atingido
- **Tentativas de retry** por transa√ß√£o
- **Transa√ß√µes com falha** por motivo

#### M√©tricas por Produto

**PIX:**

- **Taxa de QR Code expirado** por per√≠odo
- **Chaves PIX inv√°lidas** por tentativa
- **Tempo m√©dio de confirma√ß√£o** de pagamento
- **PIX fora de hor√°rio** (manuten√ß√µes)
- **Taxa de abandono** em QR Code

**Boleto:**

- **Taxa de boletos cancelados** vs emitidos
- **Boletos vencidos n√£o pagos** por per√≠odo
- **Tempo m√©dio entre emiss√£o e pagamento**
- **Erros de dados do pagador** por tipo
- **Taxa de rejei√ß√£o** por valor m√≠nimo

**Cart√£o de Cr√©dito:**

- **Taxa de aprova√ß√£o** por bandeira
- **Tokens expirados** por tentativa
- **Falhas de CVV** por transa√ß√£o
- **Tempo m√©dio de autoriza√ß√£o**
- **Taxa de chargeback** por per√≠odo

#### Dashboard Segregado

```python
def get_payment_metrics_by_method():
    return {
        'pix': {
            'success_rate': calculate_pix_success_rate(),
            'avg_confirmation_time': get_pix_avg_time(),
            'expired_qr_rate': get_expired_qr_rate(),
            'invalid_key_rate': get_invalid_key_rate()
        },
        'bank_slip': {
            'emission_rate': calculate_boleto_emission_rate(),
            'payment_rate': get_boleto_payment_rate(),
            'cancellation_rate': get_boleto_cancellation_rate(),
            'overdue_rate': get_boleto_overdue_rate()
        },
        'credit_card': {
            'approval_rate': calculate_card_approval_rate(),
            'token_success_rate': get_token_success_rate(),
            'cvv_failure_rate': get_cvv_failure_rate(),
            'chargeback_rate': get_chargeback_rate()
        }
    }

def setup_alerting_by_method():
    # Alertas PIX
    if get_pix_success_rate() < 0.95:
        alert_pix_low_success_rate()

    if get_expired_qr_rate() > 0.20:
        alert_high_qr_expiration()

    # Alertas Boleto
    if get_boleto_payment_rate() < 0.80:
        alert_low_boleto_payment_rate()

    if get_boleto_cancellation_rate() > 0.15:
        alert_high_boleto_cancellation()

    # Alertas Cart√£o
    if get_card_approval_rate() < 0.85:
        alert_low_card_approval()

    if get_cvv_failure_rate() > 0.10:
        alert_high_cvv_failures()
```

## Recupera√ß√£o de Transa√ß√µes

### Estrat√©gias de Recupera√ß√£o por Produto

#### PIX - Recupera√ß√£o R√°pida

Para PIX, implemente consulta frequente devido √† natureza instant√¢nea:

```python
def check_pending_pix_transactions():
    """Consulta PIX pendentes a cada 30 segundos"""
    pending_pix = get_pending_pix_transactions()

    for pix in pending_pix:
        try:
            # PIX tem tempo de vida limitado
            if datetime.now() - pix.created_at > timedelta(minutes=30):
                status = firebanking_client.get_pix_status(pix.transaction_id)

                if status.status == 'PAID':
                    process_pix_payment(pix, status)
                elif status.status == 'EXPIRED':
                    mark_pix_expired(pix)
                    notify_customer_pix_expired(pix)

        except Exception as e:
            log_error(f"Failed to check PIX {pix.transaction_id}: {e}")

def handle_pix_timeout():
    """Lida com PIX que n√£o foram confirmados"""
    expired_pix = get_expired_pix_transactions()

    for pix in expired_pix:
        # Gera novo PIX automaticamente
        new_pix = generate_new_pix_charge(pix.original_data)
        notify_customer_new_pix(pix.customer_email, new_pix)
```

#### Boleto - Verifica√ß√£o Di√°ria

Para boletos, implemente verifica√ß√£o di√°ria e gest√£o de vencimentos:

```python
def daily_boleto_reconciliation():
    """Verifica√ß√£o di√°ria de boletos"""
    active_boletos = get_active_boletos()

    for boleto in active_boletos:
        try:
            status = firebanking_client.get_boleto_status(boleto.boleto_id)

            if status.status == 'PAID' and boleto.local_status != 'PAID':
                process_boleto_payment(boleto, status)
            elif status.status == 'CANCELLED':
                handle_boleto_cancellation(boleto, status)
            elif status.due_date < datetime.now().date():
                handle_boleto_overdue(boleto)

        except Exception as e:
            log_error(f"Failed to check boleto {boleto.boleto_id}: {e}")

def handle_boleto_overdue(boleto):
    """Gest√£o de boletos vencidos"""
    # Notifica cliente sobre vencimento
    notify_customer_boleto_overdue(boleto)

    # Oferece renova√ß√£o autom√°tica
    if boleto.auto_renew:
        new_due_date = datetime.now().date() + timedelta(days=7)
        renewed_boleto = renew_boleto(boleto, new_due_date)
        notify_customer_boleto_renewed(boleto.customer_email, renewed_boleto)

def reissue_problematic_boletos():
    """Reemite boletos com problemas"""
    problematic = get_problematic_boletos()

    for boleto in problematic:
        try:
            # Cancela boleto problem√°tico
            firebanking_client.cancel_boleto(boleto.boleto_id)

            # Emite novo boleto
            new_boleto = create_replacement_boleto(boleto)
            notify_customer_boleto_reissued(boleto.customer_email, new_boleto)

        except Exception as e:
            log_error(f"Failed to reissue boleto {boleto.boleto_id}: {e}")
```

#### Cart√£o - Gest√£o de Autoriza√ß√µes

Para cart√£o, foque em autoriza√ß√µes pendentes e capturas:

```python
def check_pending_card_authorizations():
    """Verifica autoriza√ß√µes pendentes de cart√£o"""
    pending_auths = get_pending_card_authorizations()

    for auth in pending_auths:
        try:
            # Autoriza√ß√£o v√°lida por 7 dias
            if datetime.now() - auth.created_at > timedelta(days=6):
                status = firebanking_client.get_card_status(auth.transaction_id)

                if status.status == 'AUTHORIZED' and auth.auto_capture:
                    # Captura antes de expirar
                    capture_result = firebanking_client.capture_payment(auth.transaction_id)
                    process_card_capture(auth, capture_result)
                elif status.status == 'EXPIRED':
                    handle_authorization_expired(auth)

        except Exception as e:
            log_error(f"Failed to check card auth {auth.transaction_id}: {e}")

def handle_failed_card_captures():
    """Lida com capturas que falharam"""
    failed_captures = get_failed_card_captures()

    for capture in failed_captures:
        # Tenta captura novamente se dentro do prazo
        if datetime.now() - capture.auth_date < timedelta(days=6):
            try:
                retry_result = firebanking_client.capture_payment(capture.transaction_id)
                process_capture_retry(capture, retry_result)
            except Exception as e:
                log_error(f"Capture retry failed for {capture.transaction_id}: {e}")
                # Notifica falha definitiva
                notify_capture_failed(capture)

def cleanup_expired_tokens():
    """Remove tokens de cart√£o expirados"""
    expired_tokens = get_expired_card_tokens()

    for token in expired_tokens:
        # Remove token do banco de dados
        remove_card_token(token.token_id)

        # Notifica cliente para atualizar cart√£o
        if token.auto_renew:
            notify_customer_token_expired(token.customer_email)
```

### Recupera√ß√£o Unificada

Implemente um sistema unificado de recupera√ß√£o:

```python
def unified_transaction_recovery():
    """Sistema unificado de recupera√ß√£o"""

    # Recupera√ß√£o r√°pida para PIX (a cada 30s)
    if should_check_pix():
        check_pending_pix_transactions()

    # Recupera√ß√£o de cart√£o (a cada 5 min)
    if should_check_cards():
        check_pending_card_authorizations()
        handle_failed_card_captures()

    # Recupera√ß√£o de boleto (di√°ria)
    if should_check_boletos():
        daily_boleto_reconciliation()
        reissue_problematic_boletos()

    # Limpeza geral (semanal)
    if should_cleanup():
        cleanup_expired_tokens()
        archive_old_transactions()

# Agendar tarefas
schedule.every(30).seconds.do(check_pending_pix_transactions)
schedule.every(5).minutes.do(check_pending_card_authorizations)
schedule.every().day.at("02:00").do(daily_boleto_reconciliation)
schedule.every().week.do(cleanup_expired_tokens)
```

### Webhook de Recupera√ß√£o

Configure webhook para receber atualiza√ß√µes perdidas:

```python
@app.route('/webhook/recovery', methods=['POST'])
def recovery_webhook():
    data = request.get_json()

    # Identifica tipo de transa√ß√£o
    payment_method = data.get('payment_method')
    transaction_id = data.get('transaction_id')
    current_status = data.get('status')

    try:
        if payment_method == 'pix':
            sync_pix_transaction(transaction_id, current_status, data)
        elif payment_method == 'bank_slip':
            sync_boleto_transaction(transaction_id, current_status, data)
        elif payment_method == 'credit_card':
            sync_card_transaction(transaction_id, current_status, data)

        return '', 200

    except Exception as e:
        log_error(f"Recovery webhook failed: {e}")
        return '', 500
```

## Dashboard de Erros

Monitore erros em tempo real atrav√©s do [Dashboard FireBanking](https://app.firebanking.io):

- **Volume de erros** por per√≠odo
- **Tipos de erro** mais frequentes
- **Transa√ß√µes com falha** detalhadas
- **Health check** da API

## Pr√≥ximos Passos

<CardGroup cols={2}>
  <Card title="Implementar Retry" icon="refresh">
    Implemente as estrat√©gias de retry por produto em sua aplica√ß√£o
  </Card>
  <Card title="Configurar Monitoramento" icon="chart-line">
    Configure alertas e dashboards para erros cr√≠ticos
  </Card>
  <Card title="Testar Cen√°rios" icon="flask" href="/testing">
    Teste cen√°rios de falha no ambiente de desenvolvimento
  </Card>
  <Card title="Configurar Webhooks" icon="webhook" href="/concepts/webhooks">
    Configure webhooks e estrat√©gias de recupera√ß√£o
  </Card>
</CardGroup>

## Guias por M√©todo de Pagamento

Explore implementa√ß√µes espec√≠ficas para cada m√©todo:

<CardGroup cols={3}>
  <Card title="üöÄ PIX" href="/guides/integration/pix">
    **Instant√¢neo ‚Ä¢ 24/7 ‚Ä¢ Taxa baixa**

    Tratamento de QR Code expirado, chaves inv√°lidas

  </Card>
  <Card title="üí≥ Cart√£o de Cr√©dito" href="/guides/integration/credit-card">
    **Parcelamento ‚Ä¢ Tokens ‚Ä¢ 3DS**

    Gest√£o de autoriza√ß√µes, capturas, CVV

  </Card>
  <Card title="üè¶ Boleto Banc√°rio" href="/guides/integration/bank-slip">
    **Vencimentos ‚Ä¢ Multas ‚Ä¢ Renova√ß√£o**

    Reconcilia√ß√£o di√°ria, boletos vencidos

  </Card>
</CardGroup>

## Recursos Avan√ßados

<CardGroup cols={2}>
  <Card title="APIs de Consulta" href="/api-reference/introduction">
    Consulte status espec√≠ficos por m√©todo de pagamento
  </Card>
  <Card title="Dashboard Avan√ßado" href="https://app.firebanking.io">
    Monitore erros em tempo real com m√©tricas por produto
  </Card>
  <Card title="Ambiente de Testes" href="/testing">
    Teste todos os cen√°rios de erro por m√©todo
  </Card>
  <Card title="Melhores Pr√°ticas" href="/guides/best-practices">
    Implementa√ß√µes recomendadas para produ√ß√£o
  </Card>
</CardGroup>
